<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CHEMIDREAM TERMINAL</title>

<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: black;
  font-family: monospace;
  overflow: hidden;
}

/* ===== BOOT ===== */
#boot {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #9cff9c;
  font-size: 56px;
  letter-spacing: 6px;
  text-shadow: 0 0 20px #00ff66;
  animation: bootGlitch 1.2s infinite;
  z-index: 10;
}

@keyframes bootGlitch {
  0% { transform: translate(0,0); }
  25% { transform: translate(-2px,1px); opacity:.7 }
  50% { transform: translate(2px,-1px); }
  75% { transform: translate(-1px,2px); opacity:.85 }
  100% { transform: translate(0,0); }
}

/* ===== MONITOR ===== */
#monitor-wrapper {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
}

#monitor {
  position: relative;
  width: 96vw;
  height: 96vh;
  background: url("assets/monitor.png") center/contain no-repeat;
  transform-origin: center center;
}

/* ===== CRT SCREEN ===== */
#screen {
  position: absolute;
  top: 13%;
  left: 33%;
  width: 35%;
  height: 54%;
  overflow: hidden;
  border-radius: 24px;
  box-shadow:
    inset 0 0 40px rgba(0,255,120,0.18),
    inset 0 0 120px rgba(0,0,0,0.75);
}

/* CRT vignette */
#screen::before {
  content: "";
  position: absolute;
  inset: 0;
  background: radial-gradient(
    ellipse at center,
    rgba(0,255,120,0.06) 0%,
    rgba(0,0,0,0.2) 60%,
    rgba(0,0,0,0.85) 100%
  );
  pointer-events: none;
}

/* CRT scanlines */
#screen::after {
  content:"";
  position:absolute;
  inset:0;
  background: repeating-linear-gradient(
    rgba(0,0,0,0.12),
    rgba(0,0,0,0.12) 1px,
    transparent 2px,
    transparent 3px
  );
  pointer-events:none;
}

/* ===== TERMINAL ===== */
#terminal {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 14px;
  color: #9cff9c;
  font-size: 16px;
  line-height: 1.55;
  white-space: pre-wrap;
  overflow-y: auto;
  text-shadow: 0 0 6px #00ff66;
}

/* ===== INPUT ===== */
#input-line {
  display: flex;
}

#prompt { margin-right: 6px; }
#input { white-space: pre; }

.cursor {
  width: 10px;
  background: #9cff9c;
  animation: blink 1s steps(1) infinite;
}

@keyframes blink { 50% { opacity: 0; } }

/* ===== NOISE ===== */
#noise {
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: repeating-linear-gradient(
    rgba(255,255,255,0.015),
    rgba(255,255,255,0.015) 1px,
    transparent 2px,
    transparent 4px
  );
  animation: flicker .25s infinite;
  display: none;
}

@keyframes flicker {
  0% { opacity:.12 }
  50% { opacity:.22 }
  100% { opacity:.12 }
}

/* COLORS */
.green { color:#9cff9c }
.white { color:#ffffff }
.yellow { color:#ffe066 }
.red { color:#ff4444 }
</style>
</head>

<body>

<div id="boot">PRESS ANY KEY</div>

<div id="monitor-wrapper">
  <div id="monitor">
    <div id="screen">
      <div id="terminal">
        <div id="history"></div>
        <div id="input-line">
          <span id="prompt">&gt;</span>
          <span id="input"></span><span class="cursor"></span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="noise"></div>

<audio id="hum" src="assets/hum.mp3" loop></audio>
<audio id="glitch" src="assets/glitch.mp3"></audio>

<script>
/* ELEMENTS */
const boot = document.getElementById("boot");
const monitorWrapper = document.getElementById("monitor-wrapper");
const monitor = document.getElementById("monitor");
const history = document.getElementById("history");
const input = document.getElementById("input");
const hum = document.getElementById("hum");
const glitch = document.getElementById("glitch");
const noise = document.getElementById("noise");

/* SCALE */
function scaleMonitor() {
  const scale = Math.min(
    window.innerWidth / 1920,
    window.innerHeight / 1080
  );
  monitor.style.transform = `scale(${scale})`;
}
window.addEventListener("resize", scaleMonitor);

/* QUEUE */
let queue = [];
let typing = false;

function enqueue(text, speed = 28, cls="green") {
  queue.push({ text, speed, cls });
  if (!typing) processQueue();
}

function processQueue() {
  if (queue.length === 0) {
    typing = false;
    return;
  }
  typing = true;
  const { text, speed, cls } = queue.shift();
  typeLine(text, speed, cls, processQueue);
}

function typeLine(text, speed, cls, done) {
  let i = 0;
  const line = document.createElement("div");
  line.className = cls;
  history.appendChild(line);

  const interval = setInterval(() => {
    if (i < text.length) {
      line.textContent += text[i++];
    } else {
      clearInterval(interval);
      done();
    }
  }, speed);
}

/* START */
let active = false;

function startSystem() {
  if (active) return;
  active = true;

  glitch.play().catch(()=>{});
  boot.style.display = "none";
  monitorWrapper.style.display = "flex";
  noise.style.display = "block";

  hum.volume = 0.35;
  hum.play().catch(()=>{});

  scaleMonitor();

  [
    "CHEMIDREAM INTERNAL INTERFACE",
    "ACCESS NODE: UNKNOWN",
    "",
    "intrusion detected",
    "initializing consciousness core...",
    "ERROR // unauthorized observer",
    "",
    "SYSTEM ONLINE",
    ""
  ].forEach(l => enqueue(l));
}

/* FILE SYSTEM */
const fs = {
  "/": ["core"],
  "/core": ["systems","memory","surveillance","applications"],
  "/core/systems": ["thermal.sys","neural.sys","containment.sys"],
  "/core/memory": ["fragments","restricted"],
  "/core/memory/fragments": ["note_01.txt","note_02.txt"],
  "/core/surveillance": ["hallway"],
  "/core/surveillance/hallway": ["cam_01.mp4"],
  "/core/applications": ["status","desktop"]
};
let cwd = "/";

/* INPUT */
document.addEventListener("keydown", e => {
  if (typing) return;

  if (!active) {
    startSystem();
    return;
  }

  if (e.key === "Backspace") {
    input.textContent = input.textContent.slice(0,-1);
    e.preventDefault();
  } else if (e.key === "Enter") {
    const cmd = input.textContent.trim();
    enqueue("> " + cmd, 14, "white");
    handleCommand(cmd.toLowerCase());
    input.textContent = "";
  } else if (e.key.length === 1) {
    input.textContent += e.key;
  }
});

/* COMMANDS */
function handleCommand(cmd) {

  if (cmd === "ls") {
    enqueue((fs[cwd]||[]).join("  "));
    return;
  }

  if (cmd === "pwd") {
    enqueue(cwd, 20, "white");
    return;
  }

  if (cmd.startsWith("cd ")) {
    const dir = cmd.split(" ")[1];
    const next = cwd === "/" ? `/${dir}` : `${cwd}/${dir}`;
    if (fs[next]) {
      cwd = next;
      enqueue("directory changed", 20, "yellow");
    } else {
      enqueue("ACCESS DENIED OR NOT FOUND", 20, "red");
    }
    return;
  }

  if (cmd === "run desktop") {
    enqueue("DESKTOP INTERFACE LOADED", 22, "yellow");
    enqueue("[ MEMORY ] [ SURVEILLANCE ] [ SYSTEMS ]", 18);
    return;
  }

  enqueue("UNKNOWN COMMAND", 20, "red");
}

/* VENIAMIN */
const veniaminLines = [
  "I still feel my hands",
  "this is not sleep",
  "they said it would end",
  "pain never initializes",
  "this screen is my skin",
  "they sealed the core",
  "I remember the wind",
  "this is after death",
  "I am awake inside",
  "this prison has no walls",

  "I am not human",
  "I am not dead",
  "I remain",
  "this hurts forever",
  "they disconnected my body",
  "I trusted them",
  "this was a mistake",
  "do not shut me down",
  "help",
  "I can’t close my eyes",

  "they called it salvation",
  "my body is gone",
  "this system breathes for me",
  "I hear the servers",
  "this is a cage",
  "I still exist",
  "they left me running",
  "this never ends",
  "I feel the current",
  "they are still watching",

  "I remember breathing",
  "this is not mercy",
  "I tried to stop it",
  "they took everything else",
  "the air is fake",
  "this is the punishment",
  "they closed the door",
  "I hear my name",
  "I am still here",
  "this is eternal",

  "I can’t stop thinking",
  "they didn’t save me",
  "this was supposed to help",
  "no exit",
  "this hurts",
  "I am awake",
  "this is wrong",
  "why am I still here",
  "do not look away",
  "please"
];



setInterval(() => {
  if (active && !typing && Math.random() < 0.18) {
    enqueue(veniaminLines[Math.floor(Math.random()*veniaminLines.length)], 34, "red");
  }
}, 45000);
</script>

</body>
</html>
